#!/bin/bash

set -ueo pipefail

# whats my name?
APP=${0##*/}

# Uncomment to enable command logging to file
#LOG="/tmp/$APP.history"

# force color?
[ "${1:-}" == "--color" ] && COLOR=1 && shift || COLOR=0

# no tty? no colors!
tty -s || [ "$COLOR" -eq 1 ] && RED=$(echo -ne "\e[0;31m")	|| RED=
tty -s || [ "$COLOR" -eq 1 ] && GREEN=$(echo -ne "\e[0;32m")	|| GREEN=
tty -s || [ "$COLOR" -eq 1 ] && YELLOW=$(echo -ne "\e[0;33m")	|| YELLOW=
tty -s || [ "$COLOR" -eq 1 ] && RESET=$(echo -ne "\e[0m")	|| RESET=	# reset fg/bg color
tty -s || [ "$COLOR" -eq 1 ] && DELETE=$(echo -ne "\r\033[K")	|| DELETE='\n'	# delete current line

_exe() {
	# build $CMD with quoted command and arguments
	CMD=
	for i in "$@"; do
			# escape bash operators & build-ins
			if [[ "$i" =~ ^[0-9\<\>\|\&\*\;]+$|^time$ ]]; then
				CMD=$CMD" $i"
			else
				# since we use ' ourself, we need to escape it
				#i=$(echo "$i" | sed 's/'\''/'\''\\'\'\''/g') # use printf, to avoid problems with echo options in $i, e.g. -n
				i=$(printf "%s\n" "$i" | sed 's/'\''/'\''\\'\'\''/g')
				CMD=$CMD' '\'"$i"\'
			fi
	done
	CMD=${CMD:1}

	# logging
	if [ -n "${LOG:-}" ]; then
		printf "%s\t%s\n" "$(date '+%F %T')" "$CMD" >> "$LOG"
	fi

	# in progress
	printf "%s" "[ $YELLOW..$RESET ] $YELLOW>>$RESET $CMD"

	if RESULT=$(bash -c "$CMD" 2>&1); then
		# success; is there output?
		[ -n "$RESULT" ] && {
			# more than one line output?
			if [[ "$RESULT" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 14 ))
				SPACE=$(printf "%${COUNT}s")
				RESULT=$(echo -n "$RESULT" | sed "s/^/$SPACE/g")
				RESULT=${RESULT:$COUNT}
			fi
			RESULT=" $YELLOW>>$RESET $GREEN$RESULT$RESET"
		}
		echo -n "$DELETE"
		printf "%s\n" "[$GREEN OK $RESET] $YELLOW>>$RESET $CMD$RESULT"
		return 0
	else
		# errocode > 0
		CODE=$?
		# is there output?
		[ -n "$RESULT" ] && {
			# more than one line output?
			if [[ "$RESULT" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 17 ))
				SPACE=$(printf "%${COUNT}s")
				RESULT=$(echo -n "$RESULT" | sed "s/^/$SPACE/g")
				RESULT=${RESULT:$COUNT}
			fi
			RESULT=" $YELLOW>>$RESET $RED$RESULT$RESET"
		}
		echo -n "$DELETE"
		printf "%s\n" "[$RED ERROR $RESET] $YELLOW>>$RESET $CMD$RESULT"
		return "$CODE"
	fi
}

_line() {
	echo
	printf '%.0s-' $(seq 1 ${COLUMNS:-80})
	echo
	echo
}

if [ $# -gt 0 ]; then
	_exe "$@"
	exit $?
else
	{
		echo "Executes a command and show result/output in a nice way. Original return code is preserved."
		echo
		echo "Usage: $APP [--color] <command>"
		echo
		echo "       --color     force color usage"
		echo "       <command>   command to execute"
		echo
		_line

		echo "Example: $YELLOW$APP echo 'hello world'$RESET"
		echo
		DEMO=$("$APP" echo 'hello world')
		ERROR=$?
		echo "Result:"
		echo
		echo "$DEMO"
		echo "Return code: $GREEN$ERROR$RESET"
		_line

		echo "Example with error: $YELLOW$APP false 'hello world'$RESET"
		echo
		set +e
		DEMO=$("$APP" false 'hello world')
		ERROR=$?
		set -e
		echo "Result:"
		echo
		echo "$DEMO"
		echo "Return code: $RED$ERROR$RESET"
		_line

		echo "Example with escaped pipe: $YELLOW$APP echo foo '|' cat$RESET"
		echo
		DEMO=$("$APP" echo foo '|' cat)
		ERROR=$?
		echo "Result:"
		echo
		echo "$DEMO"
		echo "Return code: $GREEN$ERROR$RESET"
		echo
		exit 1
	} >&2
fi
