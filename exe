#!/bin/bash

# Whats my name?
APP=${0##*/}

# Uncomment to enable command logging to file
#LOG="/tmp/$APP.history"

(tty -s) && {
	RED=$(tput setaf 1)
	GREEN=$(tput setaf 2)
	YELLOW=$(tput setaf 3)
	RESET=$(tput sgr0)
	DELETE='\r\033[K'
} ||	DELETE='\n'

cleanUp() {
	[ -f "$SCRIPT" ] && {
		rm "$SCRIPT"
	}
	exit
}

trap cleanUp INT EXIT TERM

exe() {
	# Prepare script
	SCRIPT=$(mktemp "/tmp/$APP-XXX") || {
		echo -e "Error: Could not create temporary script file.\n" >&2
		exit 1
	}
	echo '#!/bin/bash' > "$SCRIPT"

	# build $CMD with quoted command and arguments
	# build script
	for i in "$@"; do
			# escape bash operators & build-ins
			if [[ "$i" =~ ^[\<\>\|\&\*\;]+$|^time$ ]]; then
				CMD=$CMD" $i"
				echo -n " $i" >> "$SCRIPT"
			else
				# since we use ' ourself, we need to escape it when writing to script
				#i=$(echo "$i" | sed 's/'\''/'\''\\'\'\''/g') # use printf, to avoid problems with echo options in $i, e.g. -n
				i=$(printf "%s\n" "$i" | sed 's/'\''/'\''\\'\'\''/g')
				CMD=$CMD' '\'"$i"\'
				echo -n " '$i'" >> "$SCRIPT"
			fi
	done
	CMD=${CMD# }
	chmod u+x "$SCRIPT"

	# Logging
	if [ -n "$LOG" ]; then
		{
			echo -ne "$(date "+%F %T")\t"
			tail -1 "$SCRIPT"
			echo
		} >> "$LOG"
	fi

	# in progress
	echo -n "[ $YELLOW..$RESET ] $YELLOW>>$RESET $CMD"
	
	if RES=$($SCRIPT 2>&1); then
		# success; is there output?
		[ -n "$RES" ] && {
			# more than one line output?
			if [[ "$RES" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 14 ))
				SPACE=$(printf "%${COUNT}s")
				RES=$(echo -n "$RES" | sed "s/^/$SPACE/g")
				RES=${RES:$COUNT}
			fi
			RES=" $YELLOW>>$RESET $GREEN$RES$RESET"
		}
		echo -en $DELETE
		echo "[$GREEN OK $RESET] $YELLOW>>$RESET $CMD$RES"
		return 0
	else
		# errocode > 0
		CODE=$?
		# is there output?
		[ -n "$RES" ] && {
			# more than one line output?
			if [[ "$RES" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 17 ))
				SPACE=$(printf "%${COUNT}s")
				RES=$(echo -n "$RES" | sed "s/^/$SPACE/g")
				RES=${RES:$COUNT}
			fi
			RES=" $YELLOW>>$RESET $RED$RES$RESET"
		}
		echo -en $DELETE
		echo "[$RED ERROR $RESET] $YELLOW>>$RESET $CMD$RES"
		return $CODE
	fi
}

if [ $# -gt 0 ]; then
	exe "$@"
	exit $?
else
	echo -e "Executes a command and show result/output in a nice way. Original return code is preserved.\n" >&2
	echo -e "Usage: $APP <command> <arguments>\n" >&2

	echo -e "Example: $APP echo 'hello world'\n" >&2
	DEMO=$("$APP" echo 'hello world')
	ERROR=$?
	echo -e "Result:\n$DEMO" >&2
	echo -e "Return code: $ERROR\n\n" >&2

	echo -e "Example with error: $APP false 'hello world'\n" >&2
	DEMO=$("$APP" false 'hello world')
	ERROR=$?
	echo -e "Result:\n$DEMO" >&2
	echo -e "Return code: $ERROR\n\n" >&2

	echo -e "Example with escaped pipe: $APP echo foo \| cat\n" >&2
	DEMO=$("$APP" echo foo \| cat)
	ERROR=$?
	echo -e "Result:\n$DEMO" >&2
	echo -e "Return code: $ERROR\n" >&2
	exit 1
fi
